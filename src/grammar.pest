// Dana Language Grammar (PEG)
// This defines the syntax of the Dana programming language

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
COMMENT = _{ "//" ~ (!"\n" ~ ANY)* ~ "\n" | "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

// Keywords
KW_NODE = @{ "node" ~ !ASCII_ALPHANUMERIC }
KW_IN = @{ "in" ~  !ASCII_ALPHANUMERIC }
KW_OUT = @{ "out" ~ !ASCII_ALPHANUMERIC }
KW_PROCESS = @{ "process" ~ !ASCII_ALPHANUMERIC }
KW_EMIT = @{ "emit" ~ !ASCII_ALPHANUMERIC }
KW_LET = @{ "let" ~ !ASCII_ALPHANUMERIC }
KW_ON = @{ "on" ~ !ASCII_ALPHANUMERIC }

// Types
type_int = { "Int" }
type_float = { "Float" }
type_string = { "String" }
type_bool = { "Bool" }
type_byte = { "Byte" }
type_unit = { "Unit" | "Trigger" }
type_stream = { "Stream" ~ "<" ~ dana_type ~ ">" }

dana_type = {
    type_stream
    | type_int
    | type_float
    | type_string
    | type_bool
    | type_byte
    | type_unit
}

// Identifiers
identifier = @{ !keyword ~ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }
keyword = { KW_NODE | KW_IN | KW_OUT | KW_PROCESS | KW_EMIT | KW_LET | KW_ON }

// Literals
int_literal = @{ "-"? ~ ASCII_DIGIT+ }
float_literal = @{ "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ }
string_literal = @{ "\"" ~ string_content ~ "\"" }
string_content = @{ (!"\"" ~ ANY)* }
bool_literal = { "true" | "false" }

// Expressions
primary_expr = {
    float_literal
    | int_literal
    | string_literal
    | bool_literal
    | lambda_expr
    | identifier
    | "(" ~ expression ~ ")"
}

lambda_expr = { "(" ~ param_list? ~ ")" ~ "=>" ~ expression }
param_list = { identifier ~ ("," ~ identifier)* }

call_expr = { identifier ~ "(" ~ arg_list? ~ ")" }
arg_list = { expression ~ ("," ~ expression)* }

unary_expr = {
    ("-" | "!") ~ unary_expr
    | postfix_expr
}

postfix_expr = {
    primary_expr ~ ("(" ~ arg_list? ~ ")")*
}

mult_op = { "*" | "/" }
mult_expr = { unary_expr ~ (mult_op ~ unary_expr)* }

add_op = { "+" | "-" }
add_expr = { mult_expr ~ (add_op ~ mult_expr)* }

comp_op = { "==" | "!=" | ">=" | "<=" | ">" | "<" }
comparison_expr = { add_expr ~ (comp_op ~ add_expr)* }

logic_and_op = { "&&" }
logical_and_expr = { comparison_expr ~ (logic_and_op ~ comparison_expr)* }

logic_or_op = { "||" }
logical_or_expr = { logical_and_expr ~ (logic_or_op ~ logical_and_expr)* }

expression = { logical_or_expr }

// Statements
emit_stmt = { KW_EMIT ~ identifier ~ "(" ~ expression ~ ")" }
let_stmt = { KW_LET ~ identifier ~ "=" ~ expression }
expr_stmt = { expression }

statement = {
    emit_stmt
    | let_stmt
    | expr_stmt
}

// Process block
process_block = {
    KW_PROCESS ~ ":" ~ "(" ~ param_list? ~ ")" ~ "=>" ~ "{" ~ statement* ~ "}"
}

// Property declaration
property_decl = {
    identifier ~ ":" ~ dana_type ~ ("=" ~ expression)?
}

// Port declaration
port_decl = {
    identifier ~ ":" ~ dana_type
}

// Node declaration
node_decl = {
    KW_NODE ~ identifier ~ "{" ~
        property_decl* ~
        (KW_IN ~ port_decl)* ~
        (KW_OUT ~ port_decl)* ~
        process_block? ~
    "}"
}

// Port reference: NodeName.portName
// Port reference: NodeName.portName or Package.Node.portName
port_ref = { identifier ~ ("." ~ identifier)+ }

// Edge operators
edge_sync = { "->" }
edge_async = { "~>" }
edge_op = { edge_async | edge_sync }

// Guard
guard = { "[" ~ expression ~ "]" }

// Edge declaration
edge_decl = {
    port_ref ~ (guard)? ~ edge_op ~ (guard)? ~ port_ref
}

// Top-level items
item = {
    node_decl
    | edge_decl
}

// Complete program
program = {
    SOI ~
    item* ~
    EOI
}
